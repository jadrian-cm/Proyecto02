#!usr/bin/python3

# Integrantes:
# Bryan Fern√°ndez S√°nchez, 2023131084
# Jos√© Carballo Mart√≠nez, 2019046749

import random
import copy
import webbrowser

matriz_visual = []
# Semillas: [nombre, turnos para crecer, turnos vivas]
semillas_f√°cil = [
    ["zinias", 2, 8],
    ["cerezos", 3, 12],
    ["tulipanes", 2, 8],
    ["rosas", 3, 12],
    ["mam√≥n chino", 2, 3],
]
semillas_medio = [
    ["zinias", 4, 10],
    ["cerezos", 3, 8],
    ["tulipanes", 3, 8],
    ["rosas", 4, 10],
    ["mam√≥n chino", 4, 10],
]
semillas_dif√≠cil = [
    ["zinias", 4, 9],
    ["cerezos", 5, 13],
    ["tulipanes", 5, 13],
    ["rosas", 5, 13],
    ["mam√≥n chino", 6, 22],
]
semillas = []

dificultad = 0  # Nivel de dificultad
mapa_juego = []  # Matriz que representa la ciudad

tipo_semillas = ["zinias", "cerezos", "tulipanes", "rosas", "mam√≥n chino"]
tipo_plantas = ["üå∑", "üåπ", "üå∫", "üåª", "üåº", "ü•Ä"]
mapa_juego_aux = []


def bienvenida():
    """
    Funci√≥n que imprime el banner de bienvenida y el
    men√∫ inicial.
    """

    print("\033[38;2;255;211;64m" + "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ                                      ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ  SOLARPUNK Y JARDINER√çA CLANDESTINA  ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ                                      ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MEN√ö PRINCIPAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ                                      ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ  [1] Iniciar juego                   ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ  [2] Instrucciones                   ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ  [3] Sobre jardiner√≠a clandestina    ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ                                      ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò" + "\033[0;m")
    print()


def men√∫_principal():
    """
    Funci√≥n que solicita al jugador que elija una opci√≥n
    y valida que la entrada sea un n√∫mero entre 1 y 3.
    """

    opci√≥n = input("\033[38;2;255;211;64m" + ">>> " + "\033[0;m")

    if not validar_opci√≥n(opci√≥n, 1, 3):
        return men√∫_principal()
    
    else:
        if int(opci√≥n) == 1:  # Iniciar juego
            print("\033[2J\033[1;1f")

        elif int(opci√≥n) == 2:  # Instrucciones
            print("\033[2J\033[1;1f")
            mostrar_contenido("https://estudianteccr-my.sharepoint.com/:b:/g/personal/jadriecmmv_estudiantec_cr/EVcp2YIaCfVCjt6CMes4HewBDjxhl0FxdGQVsFmbIrhfsQ?e=royzHo")
            return principal()

        elif int(opci√≥n) == 3:  # Solarpunk y jardiner√≠a clandestina
            print("\033[2J\033[1;1f")
            mostrar_contenido("https://estudianteccr-my.sharepoint.com/:b:/g/personal/jadriecmmv_estudiantec_cr/EetgVrxYij9PjV59zdPiRkcBehZQzRZ-IWTyj_QnQi7FMg?e=vsLffQ")
            return principal()


def mostrar_contenido(url):
    """
    Funci√≥n que abre una nueva pesta√±a en el navegador web
    con la URL proporcionada como par√°metro.
    """
    
    webbrowser.open_new(url)


def men√∫_dificultad():
    """
    Funci√≥n que muestra el men√∫ de dificultad y valida
    que la entrada del jugador sea un n√∫mero entre 1 y 4.
    """

    global dificultad

    print("\033[38;2;255;211;64m" + "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ                                      ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ  SOLARPUNK Y JARDINER√çA CLANDESTINA  ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ                                      ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DIFICULTADES DEL JUEGO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ                                      ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ  [1] F√°cil                           ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ  [2] Normal                          ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ  [3] Dif√≠cil                         ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ  [4] Personalizado                   ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îÇ                                      ‚îÇ" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò" + "\033[0;m")
    print()

    dificultad = men√∫_dificultad_aux()

    return dificultad


def men√∫_dificultad_aux():
    """
    Funci√≥n que valida la opci√≥n elegida para la dificultad.
    """

    opci√≥n = input("\033[38;2;255;211;64m" + ">>> " + "\033[0;m")
    
    print()

    if not validar_opci√≥n(opci√≥n, 1, 4):
        return men√∫_dificultad_aux()

    return int(opci√≥n)


def crear_matriz_aux():
    """
    Funci√≥n que permite escoger las dimensiones para
    crear una matriz.
    """

    global dificultad
    
    global semillas

    # Dificuldades por defecto
    if dificultad == 1:
        print("\033[2J\033[1;1f")
        mapa_juego = crear_matriz(6, 6)
        semillas = semillas_f√°cil
        return mapa_juego

    elif dificultad == 2:
        print("\033[2J\033[1;1f")
        mapa_juego = crear_matriz(10, 10)
        semillas = semillas_medio
        return mapa_juego

    elif dificultad == 3:
        print("\033[2J\033[1;1f")
        mapa_juego = crear_matriz(18, 18)
        semillas = semillas_dif√≠cil
        return mapa_juego

    # Dificultad personalizada
    elif dificultad == 4:
        filas = input("\033[38;2;255;211;64m" + "N√∫mero de filas: " + "\033[0;m")
        columnas = input("\033[38;2;255;211;64m" + "N√∫mero de columnas: " + "\033[0;m")
        
        if (not validar_opci√≥n(filas, 3, 20) or
            not validar_opci√≥n(columnas, 3, 20)):
            
            mapa_juego = crear_matriz_aux()
            return mapa_juego
        
        print("\033[2J\033[1;1f")
        mapa_juego = crear_matriz(int(filas), int(columnas))
        semillas = semillas_medio


def crear_matriz(filas, columnas):
    """
    Funci√≥n que crea una matriz con las dimensiones del
    par√°metro de entrada.
    """

    global mapa_juego

    mapa_juego = []

    # Llena la matriz con filas y columnas utilizando
    # listas por comprensi√≥n.
    for _ in range(filas):
        fila = ["üü´"] * columnas
        mapa_juego += [fila]

    return mapa_juego


def mostrar_matriz():
    """
    Funci√≥n que muestra los datos del tablero.
    """

    global mapa_juego

    for fila in mapa_juego:
        for elemento in fila:
            print(elemento, end="")
        print()  # Salto de l√≠nea despu√©s de cada fila

    print()


def men√∫_acciones():
    """
    Funci√≥n que muestra el men√∫ que le permite al usuario
    escoger una acci√≥n en el turno de juego.
    """

    print("\033[38;2;255;211;64m" + "[1] Sembrar una semilla" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "[2] Sembrar una planta" + "\033[0;m")
    print("\033[38;2;255;211;64m" + "[3] Crear una ciclov√≠a" + "\033[0;m")
    print()

    opci√≥n = input("\033[38;2;255;211;64m" + ">>> " + "\033[0;m")

    if not validar_opci√≥n(opci√≥n, 1, 3):
        return men√∫_acciones()
    
    return int(opci√≥n)


def men√∫_sembrar_semilla():
    """
    Funci√≥n que muestra el men√∫ de la opci√≥n sembrar
    semillas.
    """

    global semillas

    print()
    print("\033[38;2;255;211;64m" + "¬øQu√© semilla deseas plantar?\n" + "\033[0;m")
    print(
        "\033[38;2;255;211;64m" +
        "N¬∞----------Nombre----------Carga----------Tiempo viva" +
        "\033[0;m"
    )
    print()
    print(
        "\033[38;2;255;211;64m" +
        "0-----------" + str(semillas[0][0]) +
        "------------" + str(semillas[0][1]) +
        "-----------------" + str(semillas[0][2]) +
        "\033[0;m"
    )
    print()
    print(
        "\033[38;2;255;211;64m" +
        "1-----------" + str(semillas[1][0]) +
        "------------" + str(semillas[1][1]) +
        "-----------------" + str(semillas[1][2]) +
        "\033[0;m"
    )
    print()
    print(
        "\033[38;2;255;211;64m" +
        "2-----------" + str(semillas[2][0]) +
        "------------" + str(semillas[2][1]) +
        "-----------------" + str(semillas[2][2]) +
        "\033[0;m"
    )
    print()
    print(
        "\033[38;2;255;211;64m" +
        "3-----------" + str(semillas[3][0]) +
        "------------" + str(semillas[3][1]) +
        "-----------------" + str(semillas[3][2]) +
        "\033[0;m"
    )
    print()
    print(
        "\033[38;2;255;211;64m" +
        "4-----------" + str(semillas[4][0]) +
        "------------" + str(semillas[4][1]) +
        "-----------------" + str(semillas[4][2]) +
        "\033[0;m"
    )
    print()
    print()

    n√∫mero_semilla = input("\033[38;2;255;211;64m" + "N√∫mero de semilla: " + "\033[0;m")

    if not validar_opci√≥n(n√∫mero_semilla, 0, 4):
        return men√∫_sembrar_semilla()

    n√∫mero_semilla = semillas[int(n√∫mero_semilla)]

    return n√∫mero_semilla


def solicitar_coordenadas():
    """
    Funci√≥n que muestra el men√∫ que solicita al jugador
    el espacio donde quiere efectuar la acci√≥n previamente
    seleccionada.
    """

    global mapa_juego

    print()
    print("\033[38;2;255;211;64m" + "Inserte las coordenadas" + "\033[0;m")

    x = input("\033[38;2;255;211;64m" + "Coordenada x: " + "\033[0;m")
    y = input("\033[38;2;255;211;64m" + "Coordenada y: " + "\033[0;m")

    print()

    if (not validar_opci√≥n(x, 0, len(mapa_juego) - 1) or
        not validar_opci√≥n(y, 0, len(mapa_juego) - 1)):
        return solicitar_coordenadas()

    return int(y), int(x)


def validar_opci√≥n(opci√≥n, num1, num2):
    """
    Funci√≥n que valida datos.
    """

    if not opci√≥n.isdigit():
        print("\033[38;2;255;0;0m" + "Solo puede ingresar n√∫meros.\n" + "\033[0;m")
        return False

    if int(opci√≥n) < num1 or int(opci√≥n) > num2:
        print(
            "\033[38;2;255;0;0m" +
            "Solo n√∫meros entre " + str(num1) + " y " + str(num2) + ".\n" +
            "\033[0;m"
        )
        return False

    return True


# Estados a programar:
#  + Si en la posici√≥n mapa_juego[i][j] hay una semilla:
#     -> La municipalidad puede construir
#  + Si en la posici√≥n mapa_juego[i][j] hay una planta:
#     -> La municipalidad puede arrancarla y construir
#  + Si en la posici√≥n mapa_juego[i][j] hay una ciclov√≠a:
#     -> La municipalidad puede destruirla y en otro turno construir


def municipalidad(matriz):
    """
    Funci√≥n que compara cada posici√≥n del matriz que
    representa la ciudad y construye placas de concreto,
    destruye ciclov√≠as y arranca plantas.
    """

    filas = len(matriz)
    columnas = len(matriz[0])
    # Agrega concreto aleatoriamente entre 0 y filas // 2
    cantidad_concreto = random.randint(0, filas // 2)
    for _ in range(cantidad_concreto):
        fila = random.randint(0, filas - 1)
        columna = random.randint(0, columnas - 1)
        if matriz[fila][columna] == "üåπ":
            pass
        matriz[fila][columna] = "üî≥"



    return matriz


def verificar_fin_juego(matriz):
    """
    Funci√≥n que verifica si el jugador ha ganado o perdido.
    """

    # Verifica filas
    for fila in matriz:
        if contar_objeto("üåπ", fila=fila) == len(fila):
            print(
                "\033[38;2;0;255;0m" +
                "¬°Has ganado! Toda una fila contiene plantas." +
                "\033[0;m"
            )
            return True
    
        elif contar_objeto("üî≥", fila=fila) == len(fila):
            print(
                "\033[38;2;255;0;0m" +
                "¬°Has perdido! Toda una fila contiene concreto." +
                "\033[0;m"
            )
            return False
        
    # Verifica columnas
    for i in range(len(matriz[0])):
        columna = [fila[i] for fila in matriz]
        
        if contar_objeto("üåπ", columna=columna) == len(columna):
            print(
                "\033[38;2;0;255;0m" +
                "¬°Has ganado! Toda una columna contiene plantas." +
                "\033[0;m"
            )
            return True
        
        elif contar_objeto("üî≥", columna=columna) == len(columna):
            print(
                "\033[38;2;255;0;0m" +
                "¬°Has perdido! Toda una columna contiene concreto." +
                "\033[0;m"
            )
            return False
        
    return False  # El juego a√∫n no ha terminado


def contar_objeto(objeto, fila=None, columna=None):
    """
    Funci√≥n que cuenta la cantidad de veces que aparece
    un objeto en una fila o en una columna.
    """
    
    if fila != None and isinstance(fila, list):
        contador = 0

        for elemento in fila:
            if elemento == objeto:
                contador += 1
        
        return contador
    
    elif columna != None and isinstance(columna, list):
        contador = 0

        for elemento in columna:
            if elemento == objeto:
                contador += 1

        return contador
    
    else:
        return (
            "\033[38;2;255;0;0m" +
            "Debes especificar una fila o columna." +
            "\033[0;m"
        )


def validar_posici√≥n(x, y, objeto):
    """
    Funci√≥n que valida que un objeto se pueda poner en
    una posici√≥n en la matriz.
    """

    global tipo_plantas
    global tipo_semillas
    global mapa_juego
    global mapa_juego_aux
    
    # Verdadero inmmediato
    if mapa_juego_aux[x][y] == "üü´":
        return True
    
    if objeto in tipo_plantas:
        return True
    
    # Validar semillas
    if objeto in tipo_semillas:
        if isinstance(mapa_juego_aux[x][y], list):
            return False

        if mapa_juego_aux[x][y] != "üî≥" and objeto in tipo_semillas:       
            return True
    
        if mapa_juego_aux[x][y] == "üî≥" and objeto in tipo_semillas:
            return False
    
    # Validar ciclov√≠as
    if objeto == "üöµ":
        if mapa_juego[x][y] in tipo_plantas:
            return False
     
        if mapa_juego[x][y] in tipo_semillas:       
            return False
    
        if mapa_juego[x][y] == "üöµ":
            return False

        if  mapa_juego[x][y] == "üî≥":
            return True
        

def planta_crece(datos_objeto, x, y):
    """
    Funci√≥n que actualiza los turnos faltantes para que
    una planta crezca.
    """
    
    global tipo_plantas
    
    turnos_a_crecer = datos_objeto[1] - 1
    
    # En caso de que ya haya crecido
    if turnos_a_crecer == 0:
        cambiar_matriz_visual("üåπ", x, y)
        return [tipo_plantas[0], 0, datos_objeto[2]]

    # En caso de que a√∫n no haya crecido
    else:
        return [datos_objeto[0], turnos_a_crecer, datos_objeto[2]]


def planta_muere(datos_objetos, x, y):
    """
    Funci√≥n que actualiza los turnos faltantes para que
    una planta muera.
    """

    global tipo_plantas

    turnos_a_morir = datos_objetos[2] - 1
    
    if turnos_a_morir == 0 :
        cambiar_matriz_visual("ü•Ä", x, y)
        return "üü´"
    
    else:
        return [datos_objetos[0], 0, turnos_a_morir]


def cambiar_matriz_aux():
    """
    Funci√≥n que actualiza los datos de la matriz normal
    y auxiliar.
    """

    global mapa_juego_aux
    global tipo_plantas
    global tipo_semillas
    
    y = 0

    for columna in mapa_juego_aux:
        x = 0
        
        for fila in columna:
            if not isinstance(fila, list):
                x += 1
                pass
            
            else:
                if fila[0] in tipo_semillas:
                    mapa_juego_aux[y][x] = planta_crece(fila, x, y)
                    x += 1
                    break

                if fila[0] in tipo_plantas :
                    mapa_juego[y][x] = planta_muere(fila, x, y)
                    x += 1
                    break

                if fila[0] == "üöµ":
                    extender_ciclov√≠a(fila, x, y)
        y += 1


def cambiar_matriz_visual(√≠cono, x, y):
    """
    Funci√≥n que muestra el mapa del juego con el √≠cono
    de la semilla, planta o ciclov√≠a.
    """
    
    global mapa_juego
    
    mapa_juego[y][x] = √≠cono


def extender_ciclov√≠a(datos, x, y):
    """
    Funci√≥n que expande las ciclov√≠as.
    """

    global mapa_juego_aux

    if datos[1] == "h" and validar_posici√≥n(y, x - 1, "üöµ"):
        mapa_juego_aux[y][x - 1] == ["üöµ", "h"]
        cambiar_matriz_visual("üöµ", x - 1, y)

    if datos[1] == "v" and validar_posici√≥n(y - 1, x, "üöµ"):
        mapa_juego_aux[y - 1][x] == ["üöµ", "v"]
        cambiar_matriz_visual("üöµ", x, y - 1)


def men√∫_semillas_aux():
    """
    Funci√≥n que muestra el men√∫ que se encarga de los
    procesos para sembrar semillas.
    """

    global semillas
    global mapa_juego_aux
    global mapa_juego

    semilla = men√∫_sembrar_semilla()
    x, y = solicitar_coordenadas()

    if not validar_posici√≥n(x, y, semillas[0]):
        return men√∫_semillas_aux()
    
    cambiar_matriz_visual("üåπ", x, y)
    mapa_juego_aux[y][x] = semilla
    


def sembrar_planta():
    """
    Funci√≥n que se encarga de sembrar una planta.
    """

    global mapa_juego_aux

    x, y = solicitar_coordenadas()

    mapa_juego_aux[y][x] = "üåπ"
    cambiar_matriz_visual("üåπ", x, y)


def men√∫_ciclov√≠as():
    """
    Menu para colocar una ciclov√≠a.
    """

    global mapa_juego_aux
    
    # Parte de solicitar datos
    x, y = solicitar_coordenadas()
    
    while True:
        print("¬øEn qu√© direcci√≥n desea colocar la ciclovia?")
        direccion = input("v/h")
        
        if direccion == "h"  or direccion == "H":
            dato = ["üöµ", "h"]
            break
        
        if direccion == "v" or direccion == "V":
            dato = ["üöµ", "v"]
            break
        
        print("Solo seleccione h/v")
    # Parte de efectuar cambios
    if not validar_posici√≥n(x, y, "üöµ") :
        return men√∫_ciclov√≠as
    
    cambiar_matriz_visual("üöµ", x, y)
    mapa_juego_aux[y][x] == dato

    
def nueva_partida():
    """
    Funci√≥n que le pregunta al usuario si desea jugar
    de nuevo. El juego si no se quiere continuar y ejecuta
    la funci√≥n principal si se quiere continuar.
    """

    decisi√≥n = input(
        "\033[38;2;255;211;64m" +
        "¬øDeseas jugar otra partida? S√≠/No o S/N: " +
        "\033[0;m"
    )
    
    if type(decisi√≥n) == str:
        if decisi√≥n == "S√≠" or decisi√≥n == "S":
            print("\033[2J\033[1;1f")
            return principal()

        elif decisi√≥n == "No" or decisi√≥n == "N":
            print(
                "\033[38;2;0;255;0m" +
                "Gracias por jugar. ¬°Vuelve pronto!\n" +
                "\033[0;m"
            )
            return exit()
    
    else:
        print(
            "\033[38;2;255;0;0m" +
            "Solo puedes ingresar S√≠/No o S/N.\n" +
            "\033[0;m"
        )
        return nueva_partida()


def manejador_juego():
    """
    Funci√≥n que se encarga de mostrar siempre el mapa
    del juego actualizado y el men√∫ de acciones.
    """

    global mapa_juego
    
    while True:
        print("\033[2J\033[1;1f")
        mostrar_matriz()
        
        opci√≥n = men√∫_acciones()
        
        if opci√≥n == 1:
            men√∫_semillas_aux()
        
        if opci√≥n == 2:
            sembrar_planta()
        
        if opci√≥n == 3:
           men√∫_ciclov√≠as()
        
        cambiar_matriz_aux()
        municipalidad(mapa_juego)


def principal():
    """
    Funci√≥n que se encarga de inicializar el juego.
    """

    global dificultad
    global mapa_juego
    global mapa_juego_aux
    global matriz_visual

    bienvenida()
    men√∫_principal()
    men√∫_dificultad()
    mapa_juego = crear_matriz_aux()
    mapa_juego_aux = copy.deepcopy(mapa_juego)

    manejador_juego()


principal()
